# -*- coding: utf-8 -*-

import traceback
import socket
import string

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 


def lendian_address (maddr):
	v = str(maddr).decode("hex")
	return v[::-1].encode("hex")


def hex_escape (hhhh):
	out = ""
	for c in hhhh.decode('hex'):
		out += "\\x" + str(c.encode('hex'))

	return out


def str_pythonic_escape (hhhh):
	out = ""
	for c in hhhh:
		if c == "\\":
			out += "\\\\"

		elif c == "\'":
			out += "\\'"

		elif c == "\"":
			out += "\\\""

		elif c == "\a":
			out += "\\a"

		elif c == "\b":
			out += "\\b"

		elif c == "\f":
			out += "\\f"

		elif c == "\n":
			out += "\\n"

		elif c == "\r":
			out += "\\r"

		elif c == "\t":
			out += "\\t"

		elif c == " ":
			out += " "

		elif c in string.digits:
			out += str(c)

		elif c in string.letters:
			out += str(c)

		elif c in string.punctuation:
			out += str(c)

		else:
			out += "\\x" + str(c.encode('hex'))

	return out


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 


def pattern_create(length):
	try:
		pattern = ''
		parts = ['A', 'a', '0']
		while len(pattern) != int(length):
			pattern += parts[len(pattern) % 3]
			if len(pattern) % 3 == 0:
				parts[2] = chr(ord(parts[2]) + 1)
				if parts[2] > '9':
					parts[2] = '0'
					parts[1] = chr(ord(parts[1]) + 1)
					if parts[1] > 'z':
						parts[1] = 'a'
						parts[0] = chr(ord(parts[0]) + 1)
						if parts[0] > 'Z':
							parts[0] = 'A'
		return pattern
	except Exception, e:
		return -1



def pattern_offset(value):
	# value:		valore del registro EIP
	v = str(value).decode("hex")
	pattern = pattern_create(10000)
	try:
		return pattern.index(v[::-1])		# Ruoto la stringa per convertire in "Little Endian"
	except Exception, e:
		return -1


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 


# Funzione utilizzata per identificare i badchar analizzando una stringa copiata dal debbuger
# Usando immunity DBG: selezionare il testo e fare Binary -> Binary Copy

def analyze_badchar (in_string, ex_chars):
	# in_string:	stringa copiata dal debbuger
	# ex_chars:		caratteri gia' esclusi (deve essere un array di char da escludere)
	try:
		badchar_arr = [
			"\x00", "\x01", "\x02", "\x03", "\x04", "\x05", "\x06", "\x07", "\x08", "\x09", "\x0a", 
			"\x0b", "\x0c", "\x0d", "\x0e", "\x0f", "\x10", "\x11", "\x12", "\x13", "\x14", "\x15", 
			"\x16", "\x17", "\x18", "\x19", "\x1a", "\x1b", "\x1c", "\x1d", "\x1e", "\x1f", "\x20", 
			"\x21", "\x22", "\x23", "\x24", "\x25", "\x26", "\x27", "\x28", "\x29", "\x2a", "\x2b", 
			"\x2c", "\x2d", "\x2e", "\x2f", "\x30", "\x31", "\x32", "\x33", "\x34", "\x35", "\x36", 
			"\x37", "\x38", "\x39", "\x3a", "\x3b", "\x3c", "\x3d", "\x3e", "\x3f", "\x40", "\x41", 
			"\x42", "\x43", "\x44", "\x45", "\x46", "\x47", "\x48", "\x49", "\x4a", "\x4b", "\x4c", 
			"\x4d", "\x4e", "\x4f", "\x50", "\x51", "\x52", "\x53", "\x54", "\x55", "\x56", "\x57", 
			"\x58", "\x59", "\x5a", "\x5b", "\x5c", "\x5d", "\x5e", "\x5f", "\x60", "\x61", "\x62", 
			"\x63", "\x64", "\x65", "\x66", "\x67", "\x68", "\x69", "\x6a", "\x6b", "\x6c", "\x6d", 
			"\x6e", "\x6f", "\x70", "\x71", "\x72", "\x73", "\x74", "\x75", "\x76", "\x77", "\x78", 
			"\x79", "\x7a", "\x7b", "\x7c", "\x7d", "\x7e", "\x7f", "\x80", "\x81", "\x82", "\x83", 
			"\x84", "\x85", "\x86", "\x87", "\x88", "\x89", "\x8a", "\x8b", "\x8c", "\x8d", "\x8e", 
			"\x8f", "\x90", "\x91", "\x92", "\x93", "\x94", "\x95", "\x96", "\x97", "\x98", "\x99", 
			"\x9a", "\x9b", "\x9c", "\x9d", "\x9e", "\x9f", "\xa0", "\xa1", "\xa2", "\xa3", "\xa4", 
			"\xa5", "\xa6", "\xa7", "\xa8", "\xa9", "\xaa", "\xab", "\xac", "\xad", "\xae", "\xaf", 
			"\xb0", "\xb1", "\xb2", "\xb3", "\xb4", "\xb5", "\xb6", "\xb7", "\xb8", "\xb9", "\xba", 
			"\xbb", "\xbc", "\xbd", "\xbe", "\xbf", "\xc0", "\xc1", "\xc2", "\xc3", "\xc4", "\xc5", 
			"\xc6", "\xc7", "\xc8", "\xc9", "\xca", "\xcb", "\xcc", "\xcd", "\xce", "\xcf", "\xd0", 
			"\xd1", "\xd2", "\xd3", "\xd4", "\xd5", "\xd6", "\xd7", "\xd8", "\xd9", "\xda", "\xdb", 
			"\xdc", "\xdd", "\xde", "\xdf", "\xe0", "\xe1", "\xe2", "\xe3", "\xe4", "\xe5", "\xe6", 
			"\xe7", "\xe8", "\xe9", "\xea", "\xeb", "\xec", "\xed", "\xee", "\xef", "\xf0", "\xf1", 
			"\xf2", "\xf3", "\xf4", "\xf5", "\xf6", "\xf7", "\xf8", "\xf9", "\xfa", "\xfb", "\xfc", 
			"\xfd", "\xfe", "\xff"
		]

		for c in ex_chars:							# Rimuovo i caratteri precedentemente esclusi
			badchar_arr.remove(c.decode('hex'))

		stripped_string = in_string.replace(' ' , '').replace('\n' , '')
		escaped_string = stripped_string.decode('hex')

		for i in range(0,len(badchar_arr)):		# Provo a rimuovere il carattere, in caso contrario ho un eccezione
			if ((badchar_arr[i] == "\x00") and (badchar_arr[i+1] != escaped_string[i+1])):
				return [ badchar_arr[i].encode('hex') ]

			elif (badchar_arr[i] != escaped_string[i]):
				return [ badchar_arr[i-1].encode('hex') ]

		return 0

	except Exception, e:
		traceback.print_exc(e)
		return -3


#print analyze_badchar ("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff", ['00'])


#pattern_create(10000)
#print pattern_offset(39694438)


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

# Funzione utilizzata per identificare lo spazio disponibile per la payload dopo i byte per l'EIP
# Usando immunity DBG: selezionare il testo e fare Binary -> Binary Copy
def extra_space_offset (in_string):
	# offset:		grandezza dell'offset
	try:
		stripped_string = in_string.replace(' ' , '').replace('\n' , '')
		escaped_string = stripped_string.decode('hex')

		return len(escaped_string)
	except Exception, e:
		traceback.print_exc(e)
		return -3




# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

'''
def find_badchar (in_string):
	# in_string:		stringa copiata dal debbuger
	try:
		badchar_arr = [
			"\x00", "\x01", "\x02", "\x03", "\x04", "\x05", "\x06", "\x07", "\x08", "\x09", "\x0a", 
			"\x0b", "\x0c", "\x0d", "\x0e", "\x0f", "\x10", "\x11", "\x12", "\x13", "\x14", "\x15", 
			"\x16", "\x17", "\x18", "\x19", "\x1a", "\x1b", "\x1c", "\x1d", "\x1e", "\x1f", "\x20", 
			"\x21", "\x22", "\x23", "\x24", "\x25", "\x26", "\x27", "\x28", "\x29", "\x2a", "\x2b", 
			"\x2c", "\x2d", "\x2e", "\x2f", "\x30", "\x31", "\x32", "\x33", "\x34", "\x35", "\x36", 
			"\x37", "\x38", "\x39", "\x3a", "\x3b", "\x3c", "\x3d", "\x3e", "\x3f", "\x40", "\x41", 
			"\x42", "\x43", "\x44", "\x45", "\x46", "\x47", "\x48", "\x49", "\x4a", "\x4b", "\x4c", 
			"\x4d", "\x4e", "\x4f", "\x50", "\x51", "\x52", "\x53", "\x54", "\x55", "\x56", "\x57", 
			"\x58", "\x59", "\x5a", "\x5b", "\x5c", "\x5d", "\x5e", "\x5f", "\x60", "\x61", "\x62", 
			"\x63", "\x64", "\x65", "\x66", "\x67", "\x68", "\x69", "\x6a", "\x6b", "\x6c", "\x6d", 
			"\x6e", "\x6f", "\x70", "\x71", "\x72", "\x73", "\x74", "\x75", "\x76", "\x77", "\x78", 
			"\x79", "\x7a", "\x7b", "\x7c", "\x7d", "\x7e", "\x7f", "\x80", "\x81", "\x82", "\x83", 
			"\x84", "\x85", "\x86", "\x87", "\x88", "\x89", "\x8a", "\x8b", "\x8c", "\x8d", "\x8e", 
			"\x8f", "\x90", "\x91", "\x92", "\x93", "\x94", "\x95", "\x96", "\x97", "\x98", "\x99", 
			"\x9a", "\x9b", "\x9c", "\x9d", "\x9e", "\x9f", "\xa0", "\xa1", "\xa2", "\xa3", "\xa4", 
			"\xa5", "\xa6", "\xa7", "\xa8", "\xa9", "\xaa", "\xab", "\xac", "\xad", "\xae", "\xaf", 
			"\xb0", "\xb1", "\xb2", "\xb3", "\xb4", "\xb5", "\xb6", "\xb7", "\xb8", "\xb9", "\xba", 
			"\xbb", "\xbc", "\xbd", "\xbe", "\xbf", "\xc0", "\xc1", "\xc2", "\xc3", "\xc4", "\xc5", 
			"\xc6", "\xc7", "\xc8", "\xc9", "\xca", "\xcb", "\xcc", "\xcd", "\xce", "\xcf", "\xd0", 
			"\xd1", "\xd2", "\xd3", "\xd4", "\xd5", "\xd6", "\xd7", "\xd8", "\xd9", "\xda", "\xdb", 
			"\xdc", "\xdd", "\xde", "\xdf", "\xe0", "\xe1", "\xe2", "\xe3", "\xe4", "\xe5", "\xe6", 
			"\xe7", "\xe8", "\xe9", "\xea", "\xeb", "\xec", "\xed", "\xee", "\xef", "\xf0", "\xf1", 
			"\xf2", "\xf3", "\xf4", "\xf5", "\xf6", "\xf7", "\xf8", "\xf9", "\xfa", "\xfb", "\xfc", 
			"\xfd", "\xfe", "\xff"
		]

		stripped_string = in_string.replace(' ' , '').replace('\n' , '')
		escaped_string = stripped_string.decode('hex')

		removed = []

		for c in escaped_string:		# Provo a rimuovere il carattere, in caso contrario ho un eccezione
			badchar_arr.remove(c)
			removed.append(c)

		return removed

	except Exception, e:
		traceback.print_exc(e)
		return -3
'''

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
